\فصل{راه‌حل پیشنهادی}

در توضیح راه حل نیز مثال بیان شده در قسمت قبل را ادامه می‌دهیم.

در روش پیشنهادی برای پیش‌بینی سرعت ترافیک در نقاط مختلف از هر دو نوع ویژگی زمانی و مکانی بهره می‌بریم.
در روش‌های پیشین مانند \مرجع{1506.04214} برای استفاده از ویژگی‌های مکانی، از پیچش\پانویس{convolution} معمول که عمدتا در پردازش تصویر از آن بهره می‌گیرند استفاده شده است، این پیچش تنها می‌تواند بر روی داده‌هایی اعمال شود که ساختار مشبک دارند (مانند عکس و فیلم).
در این روش برای آنکه بتوانیم از اطلاعات مکانی حداکثر استفاده را ببریم به جای آنکه شبکه‌ی ترافیک را مانند یک شبکه‌‌ی شطرنجی\پانویس{Grid} ببینیم،
آن را به وسیله‌ی یک گراف مدل می‌کنیم و پیچش را مستقیما بر روی این گراف اعمال می‌کنیم.

گره‌های این گراف نقاطی مشخص هستند که سرعت ترافیک را در آن‌ها داشته باشیم، در این مثال نقاط ما میدان‌های فاطمی و فلسطین هستند،
سرعت در این نقاط به طور مثال می‌تواند از طریق دوربین‌های سرعت سنج یا از طریق سیستم موقعیت‌‌یاب‌جهانی\پانویس{GPS} رانندگان تشخیص داده شود.

\begin{figure}
  \includegraphics{./images/base.png}
  \centering
  \caption{
نمایش رابطه \رجوع{eq:base} به صورت شهودی.
گراف مسیر یکسان است و هر دیاگرام نشان‌دهنده‌ی سرعت ترافیک در گره‌های این گراف در یک لحظه متفاوت است.
}
  \label{fig:base}
\end{figure}

بدیهی است تغییر سرعت ترافیک در یک گره‌ی گراف می‌تواند باعث تغییر سرعت ترافیک در گره‌های مجاور شود و هر چه فاصله‌ی دو گره از یک دیگر کم تر باشد این اثرگذاری قوی‌تر است.
برای نمایش این عامل به صورت کمی از ماتریس $W$ استفاده می‌کنیم، ابعاد این ماتریس به صورت $n \times n$ است که $n$ برابر تعداد گره‌های گراف است و هر مقدار داخل این ماتریس تابعی از فاصله‌ی بین دو گره متناظر است که مقدار آن با کاهش این فاصله بیشتر می‌شود.

در شکل \رجوع{fig:base} $W_{i,j}$ مقدار ماتریس $W$ در خانه‌ی $i$ و $j$ است که نشان دهنده‌ی میزان ارتباط مکانی و همبستگی بین گره‌های $i$ و $j$ می‌باشد.
در این مثال گره‌های $i$ و $j$ همان میادین یاد شده هستند و $W_{i,j}$ با توجه به فاصله‌ی مکانی این دو میدان نشان می‌دهد که
به طور مثال اگر سرعت ترافیک در میدان فاطمی کاهش پیدا کند این موضوع چقدر می‌تواند بر روی سرعت ترافیک در میدان فلسطین تاثیر بگذارد.
در این پروژه از رابطه‌ \رجوع{eq:distance} برای بدست آوردن خانه‌های ماتریس $W$ استفاده می‌کنیم \مرجع{1709.04875}:

\begin{equation}
  W_{i,j} = \left\{
    \begin{array}{ll}
      \exp(-\frac{d^{2}_{ij}}{\sigma^{2}}) & , i \neq j \quad and \quad \exp(-\frac{d^{2}_{ij}}{\sigma^{2}}) \geq \epsilon \\
      0 & , otherwise. \\
    \end{array}\right.
  \label{eq:distance}
\end{equation}

\begin{table}[h]
  \centering
  \caption{توضیح پارامترهای رابطه \رجوع{eq:distance}}
  \begin{tabular}{|c|p{0.5\textwidth}|}
    \hline
    $W_{ij}$ & میزان ارتباط مکانی بین گره‌های $i$ و $j$ \\
    \hline
    $d_{ij}$ & فاصله ی مکانی بین گره‌های $i$ و $j$ \\
    \hline
    $\sigma$, $\epsilon$ & پارامترهای ثابت برای کنترل میزان تنک\پانویس{Sparsity} بودن ماتریس $W$ \\
    \hline
  \end{tabular}
  \label{tbl:distance}
\end{table}

در مثال ما فاصله بین میدان‌های فاطمی و فلسطین برابر $1.7$ کیلومتر است.
هرچه $\epsilon$ را افزایش دهیم باعث می‌شود تنها ارتباطات قوی‌تر را به حساب بیاوریم و ماتریس تنک‌تر می‌شود
همچنین هرچه $\sigma$ را کاهش دهیم عددی که به عنوان میزان ارتباط محاسبه می‌کنیم کاهش یافته و ماتریس تنک‌تر می‌شود.

با توجه به توضیحات بالا برنامه توسعه‌یافته‌ی نهایی بر اساس این مدل برای عملکرد به دو فایل ورودی احتیاج دارد که اطلاعات درج شده در شکل \رجوع{fig:blackbox} را در اختیار برنامه قرار دهند.
فایل اول شامل ماتریس $W$ است که پیشتر توضیح داده شد و گراف یا به عبارتی وزن یال‌ها را شرح می‌دهد،
فایل دیگر شامل سرعت ترافیک در نودهای این گراف در بازه‌های زمانی متوالی است که در اختیار مدل قرار می‌گیرد $(V_{t}, \ldots, V_{t-M+1})$.
در خروجی، سرعت ترافیک پیش‌بینی شده در نودها در قدم‌های زمانی بعدی برگردانده می‌شود $\hat{V}$.
در مثال ما فایل‌های ذکر شده فرمتی مانند جدول \رجوع{tbl:speed-example} و \رجوع{tbl:distance-example} دارند البته اعداد زیر به صورت تصادفی و فرضی هستند.

\begin{figure}
  \includegraphics[height=3cm]{./images/blackbox.png}
  \centering
  \caption{
در یک نگاه سطح بالا برنامه با دانستن گراف و سرعت ترافیک در گره‌های این گراف در $M$ واحد زمانی گذشته سرعت ترافیک در $H$ واحد زمانی بعدی را تخمین زده و برمی‌گرداند.
  }
  \label{fig:blackbox}
\end{figure}

\شروع{لوح}[h]
\شرح{مثالی از فرمت فایل ورودی برنامه که شامل سرعت ترافیک در میادین فلسطین و فاطمی در سه قدم زمانی است.}
\تنظیم‌ازوسط
\برچسب{tbl:speed-example}
\شروع{جدول}{|c|c|c|c|}
\خط‌پر
۲ بعد از ظهر & ۱:۵۵ بعد از ظهر & ۱:۵۰ بعد از ظهر & \\
\خط‌پر
۳۶ کیلومتر بر ساعت & ۳۲ کیلومتر بر ساعت & ۴۰ کیلومتر بر ساعت & میدان فلسطین \\
\خط‌پر
۱۷ کیلومتر بر ساعت & ۲۷ کیلومتر بر ساعت & ۱۰ کیلومتر بر ساعت & میدان فاطمی \\
\خط‌پر
\پایان{جدول}
\پایان{لوح}

\شروع{لوح}[h]
\شرح{مثالی از فرمت فایل ورودی برنامه که شامل وزن یالها برای نشان دادن میزان ارتباط مکانی است.}
\تنظیم‌ازوسط
\برچسب{tbl:distance-example}
\شروع{جدول}{|c|c|c|}
\خط‌پر
میدان فاطمی & میدان فلسطین & \\
\خط‌پر
۳۱۶ & ۰ & میدان فلسطین \\
\خط‌پر
۰ & ۳۱۶ & میدان فاطمی \\
\خط‌پر
\پایان{جدول}
\پایان{لوح}


برای سادگی گراف را بدون جهت در نظر می‌گیریم و در نتیجه $W$ ماتریسی متقارن است.

برنامه برای آنکه بتواند هم ارتباطات مکانی و هم ارتباطات زمانی را یاد بگیرد باید از بلوک‌هایی تشکیل شده باشد که هر دو نوع لایه پیچشی زمانی و مکانی را در خود داشته باشند.
همانطور که در شکل \رجوع{fig:blocks} نشان داده شده است، ساختار برنامه از دو بلوک پیچشی زمانی-مکانی و یک لایه‌ی خروجی کاملا متصل در انتها تشکیل شده است.

\شروع{شکل}
  \درج‌تصویر[height=.5\textheight]{./images/blocks.png}
  \تنظیم‌ازوسط
  \شرح{شبکه‌ی پیچشی زمانی-مکانی بر روی گراف \مرجع{1709.04875}}
  \برچسب{fig:blocks}
\پایان{شکل}

هر بلوک پیچشی زمانی-مکانی که در شکل \رجوع{fig:inner-blocks} نشان داده شده است از دو لایه‌ی پیچشی زمانی تشکیل شده است که در ورودی و خروجی قرار گرفته‌اند
و یک لایه‌ی پیچش مکانی گراف مانند پلی بین آن دو قرار گرفته است، که می‌تواند با سرعت خوبی اطلاعات مکانی را پس از اعمال پیچش روی گراف
به پیچش‌های زمانی انتشار دهد.

\begin{figure}
  \includegraphics[height=8cm]{./images/inner-blocks.png}
  \centering
  \caption{
ساختار بلوک پیچشی زمانی-مکانی. گراف مسیرها تنها در لایه‌ی پیچش مکانی گراف استفاده می‌شود. \مرجع{1709.04875}
  }
  \label{fig:inner-blocks}
\end{figure}

در این پروژه برای استخراج ویژگی‌های مکانی از پیچش روی گراف استفاده می‌کنیم و بدیهی است پیچش استاندارد که معمولا
در بحث پردازش تصویر روی تصاویر اعمال می‌کنیم در این مساله قابل استفاده نیست
چرا که در پردازش تصویر پیچش عملا کار الگویابی\پانویس{Pattern Matching} را انجام می‌دهد اما در گراف که رئوس جای مشخصی ندارد
و راس‌های یک گراف را می‌توان به صورت‌های مختلفی
شماره‌گذاری کرد نمی‌توان از پیچش انتظار الگویابی داشت.
و باید از مدل عمومی‌تری استفاده کنیم.

در پردازش تصویر از کرنل‌هایی مانند شکل \رجوع{fig:2d-convolution} استفاده می‌شود. تمامی خانه‌ها همواره در جای مشخص خود و با ترتیب ثابت قرار گرفته‌اند
برای مثال خانه‌ی $j3$ همیشه در گوشه بالا قرار گرفته است.

\begin{figure}
  \includegraphics[]{./images/2d-convolution.png}
  \centering
  \caption{کرنل پیچش دو بعدی}
  \label{fig:2d-convolution}
\end{figure}

می‌خواهیم کرنل شکل \رجوع{fig:graph-convolution-kernel}
به گراف شکل \رجوع{fig:graph-convolution-graph} اعمال کنیم و واضح است که یک نام‌گذاری با ترتیب یکسان برای گراف و کرنل وجود ندارد.


\begin{figure}
  \includegraphics[]{./images/graph-convolution-kernel.png}
  \centering
  \caption{کرنل پیچش گراف}
  \label{fig:graph-convolution-kernel}
\end{figure}

\begin{figure}
  \includegraphics[]{./images/graph-convolution-graph.png}
  \centering
  \caption{گراف مقصد پیچش گراف}
  \label{fig:graph-convolution-graph}
\end{figure}

در این پژوهش از پیچش طیفی روی گراف‌\پانویس{Spectral Graph Convolution} استفاده می‌کنیم. \مرجع{1312.6203}

با استفاده از رابطه \رجوع{eq:convolution} می‌توانیم پیچش روی گراف را انجام دهیم تا الگوها و ویژگی‌های با معنی را در دامنه‌ی فضا پیدا کنیم.

\begin{equation}
  \Theta *_{g} \chi = \Theta(L)\chi = \Theta(U \Lambda U^{T})\chi = U\Theta(\Lambda)U^{T}\chi
  \label{eq:convolution}
\end{equation}

\begin{table}[h]
  \centering
  \caption{توضیح پارامترهای رابطه \رجوع{eq:convolution}}
  \begin{tabular}{|c|p{0.5\textwidth}|}
    \hline
    $*_{g}$ & عامل پیچش مکانی روی گراف \\
    \hline
    $\chi$ & سیگنال گراف که در این مدل خروجی لایه‌ی پیچش زمانی اول است \\
    \hline
    $\Theta$ & کرنل \\
    \hline
    $L$ & ماتریس لاپلاسین نرمال شده‌ی گراف \\
    \hline
    $U$ & ماتریس بردار ویژه‌های ماتریس $L$ \\
    \hline
    $\Lambda$ & ماتریس قطری مقدار ویژه‌های ماتریس $L$ \\
    \hline
  \end{tabular}
  \label{tbl:distance}
\end{table}

در مثال ذکر شده اگر محاسبات را انجام دهیم، خواهیم داشت:

\[
U = \left(
  \begin{array}{cc}
  1 & -1 \\
  1 & 1 \\
  \end{array}
\right),
\Lambda = \left(
  \begin{array}{cc}
  0 & 0 \\
  0 & 2 \\
  \end{array}
\right),
L = \left(
  \begin{array}{cc}
  1 & -1 \\
  -1 & 1 \\
  \end{array}
\right)
\]

در نظر داشته باشید که المان‌های ماتریس $\Theta$ در ابتدا به صورت تصادفی انتخاب می‌شوند.

\قسمت{کاهش پیچیدگی زمانی}

پیچیدگی زمانی این رابطه $O(n^{2})$ است که بسیار سنگین است، برای سبک شدن محاسبات باید از یک تخمین به جای استفاده مستقیم از این رابطه بهره می‌بریم.
در این پروژه از تخمین چند جمله‌ای چبیشف\پانویس{Chebyshev} استفاده می‌کنیم.

برای متمرکز و محلی کردن فیلتر و کاهش تعداد پارامترها، می‌توان کرنل $\Theta$ را به یک چند جمله‌ای از $\varLambda$ محدود کرد.

\[
  \Theta(\varLambda) = \sum_{k=1}^{k-1}\Theta_{k}\varLambda^{k}
\]

$k$ اندازه کرنل در پیچش گراف است که شعاع بیشینه پیچش از یک گره مرکزی را مشخص می‌کند. از چند جمله‌ای چبیشف ( $T_{k}(x)$ ) استفاده می‌کنیم تا کرنل‌ها را به صورت انبساطی کوتاه شده از مرتبه‌ی $k-1$ تخمین بزنیم.

\[
  \Theta(\varLambda) \approx \sum_{k=1}^{k-1}\Theta_{k}T_{k}(\widetilde{\varLambda})
\]
\[
  \widetilde{\varLambda} = \frac{2\varLambda}{\lambda_{\max}} - I_{n}
\]

% \begin{table}[h]
%   \centering
%   \caption{توضیح پارامترهای رابطه \رجوع{eq:convolution}}
%   \begin{tabular}{|c|p{0.5\textwidth}|}
%     \hline
%     $\Lambda$ & ماتریس قطری مقدار ویژه‌های ماتریس $L$ \\
%     \hline
%     $\lambda_{\max}$
%     & بزرگ‌ترین مقدار ویژه‌ی ماتریس لاپلاسین \\
%     \hline
%     $\Theta$ & کرنل \\
%     \hline
%     $L$ & ماتریس لاپلاسین نرمال شده‌ی گراف \\
%     \hline
%     $U$ & ماتریس بردار ویژه‌های ماتریس $L$ \\
%     \hline
%     $\widetilde{\varLambda}$
%     & $\varLambda$ اسکیل شده \\
%     \hline
%   \end{tabular}
%   \label{tbl:distance}
% \end{table}

حال می‌توانیم پیچش روی گراف را اینگونه بازنویسی کنیم:

\begin{equation}
  \Theta \ast_{g} x = \Theta(L)x \approx \sum_{k=0}^{k-1} \Theta_{k} T_{k}(\widetilde{L})x
  \label{eq:approx-convolution}
\end{equation}

$T_{k}(\widetilde{L} \in R^{n \times n})$ چند جمله‌ای چبیشف از مرتبه‌ی $k$ است که به وسیله‌ی لاپلاسین اسکیل شده محاسبه می‌شود.

\[
  \widetilde{L} = \frac{2\widetilde{L}}{\lambda_{\max}} - I_{n}
\]

از تقریب چند جمله‌ای استفاده می‌کنیم و به طور بازگشتی $k$ پیچش‌های محلی را محاسبه می‌کنیم. اینگونه می‌توانیم رابطه‌ی \رجوع{eq:convolution}
را با رابطه‌ی \رجوع{eq:approx-convolution} تخمین بزنیم و پیچیدگی محاسباتی را از $O(n^{2})$ به $O(k|\epsilon|)$
کاهش دهیم.

\قسمت{تعمیم دادن کانولوشن روی گراف}
\پاراگراف{}
عامل کانولوشن بر روی گراف ($*_g$) که پیشتر تعریف کردیم تنها می توانست بر روی یک $x \in R^n$ اعمال شود. می توانیم آن را تعمیم دهیم به طوری که بر روی تنسورهای چندبعدی نیز قابل اعمال باشد. برای سیگنالی با $c_i$ کانال ($X \in R^{n*c_i}$) کانولوشن روی گراف را می توان اینگونه تعمیم داد:

\begin{equation}
y_i = \sum_{i=1}^{C_i} \Theta _{i,j}(L)x_i \in R^n , 1 <= j <= C_o
    \label{eq:graph-convolution-generalization}
\end{equation}

\begin{table}[h]
  \centering
  \caption{توضیح پارامترهای رابطه \رجوع{eq:graph-convolution-generalization}}
  \begin{tabular}{|c|p{0.5\textwidth}|}
    \hline
    $C_i$ & سایز ورودی نگاشت ویژگی\پانویس{feature map} \\
    \hline
    $C_o$ & سایز خروجی نگاشت ویژگی \\
    \hline
    $\Theta_{i,j} \in R^k$ & بردارهای ضرایب چبیشف که تعداد آن‌ها
    $C_i * C_o$
    می‌شود.\\
    \hline
  \end{tabular}
  \label{tbl:distance}
\end{table}

\پاراگراف{}
کانولوشن بر روی گراف برای متغیرهای دو بعدی به صورت $\Theta *_g X$ نشان داده می‌شود ($\Theta \in R^{K*C_i*C_o}$. در این پروژه برای پیش‌بینی سرعت ترافیک، ورودی از $M$ صفحه تشکیل شده‌است که هر صفحه گراف مسیرها را در یک گام زمانی نشان می‌دهد ( شکل \رجوع{fig:base}). هر صفحه مربوط به گام زمانی $t$ را می توان به صورت یک ماتریس دید که ستون $i$ ام آن مقدار $C_i$ بعدی از سرعت ترافیک در گره $i$ ام از گراف است ($X \in R^{n * C_i}$)

\قسمت{لایه‌ی پیچشی زمانی}
\پاراگراف{}
در مسائل سری زمانی، شبکه‌های عصبی بازگشتی بسیار رایج‌اند اما در مسائل ترافیکی استفاده از این شبکه‌ها بسیار زمان‌بر است.
همچنین در ترافیک تغییرات به صورت پویا می‌باشند که این شبکه دیر به این تغییرات جواب می‌دهد،
در طرف دیگر شبکه های عصبی پیچشی به سرعت آموزش داده می‌شوند و ساختار ساده‌ای دارند، در نتیجه برای استخراج ویژگی‌های زمانی در این پروژه با الهام از
\مرجع{1409.3215} از ساختارهای کاملا پیچشی بر روی محور زمان استفاده می‌کنیم تا بتوانیم رفتار پویای سرعت ترافیک را دنبال کنیم.

\begin{figure}
  \includegraphics[height=8cm]{./images/time-conv.png}
  \centering
  \caption{
ساختار لایه‌ی کانولوشنی زمانی \مرجع{1709.04875}
  }
  \label{fig:time-conv}
\end{figure}

\پاراگراف{}
شکل \رجوع{fig:time-conv} لایه‌ی پیچشی زمانی را نشان می‌دهد که شامل یک پیچش علّی یک بعدی\پانویس{1-D casual convolution}
با یک فیلتر به عرض  $k_{t}$ است که پس از آن یک واحد خطی دروازه‌ای\پانویس{Gated Linear Unit} قرار دارد.
برای هر گره در گراف $g$ پیچش زمانی بر روی تمامی $K_{t}$ همسایه‌ی ورودی اعمال می‌شود.
در این پیچش لایه گذاری\پانویس{padding} وجود ندارد‌‌، در نتیجه، پیچش در هر مرتبه باعث کوتاه‌تر شدن توالی‌ها به اندازه‌ی $K_{t}-1$ می‌شود.
با این توضیحات می‌توانیم رابطه‌ی \رجوع{eq:time-conv} را بیان کنیم.

\begin{equation}
  \Gamma *_{\tau} Y = P \odot \sigma (Q) \in R^{M-K_{t}+1 \times C_{O}}
  \label{eq:time-conv}
\end{equation}

\begin{table}[h]
  \centering
  \caption{توضیح پارامترهای رابطه \رجوع{eq:time-conv}}
  \begin{tabular}{|c|p{0.5\textwidth}|}
    \hline
    $*_{g}$ & عامل پیچش زمانی \\
    \hline
    $Y$ & سرعت ترافیک در گره‌های مختلف گراف در گام‌های زمانی گذشته \\
    \hline
    $\Gamma$ & کرنل پیچش که المان‌های آن در ابتدا به صورت تصادفی انتخاب می‌شوند. \\
    \hline
    $P$, $Q$ & پس از آنکه با استفاده از کرنل $\Gamma$ یک پیچش روی $Y$ اعمال کردیم خروجی را برحسب سایز کانال خروجی لایه به دو نیمه‌ی مساوی تقسیم می‌کنیم که یکی $P$ و دیگری را $Q$ می‌نامیم. \\
    \hline
    $\odot$ & نمایشگر عملیات ضرب درایه‌ای \\
    \hline
    $M$ & تعداد گام‌های زمانی استفاده شده برای آموزش \\
    \hline
    $K_{t}$ & سایز کرنل \\
    \hline
    $C_{O}$ & سایز کانال خروجی \\
    \hline
  \end{tabular}
  \label{tbl:distance}
\end{table}

 $P$ و $Q$ پس از محاسبه به عنوان ورودی به واحد خطی دروازه‌ای داده می‌شوند، این واحد باعث غیرخطی شدن محاسبات این لایه می‌شود.

ورودی $Y$ چهار بعدی است، بُعد اول برابر تعداد کل داده‌هایی است که در اختیار داریم، بُعد دوم برابر
تعداد گام‌های گذشته است، که قصد داریم برای پیش‌بینی استفاده کنیم،
بُعد سوم برابر تعداد گره‌های گراف و در نهایت بُعد آخر سایز کانال ورودی است.
در مثالی که با آن پیش می‌رویم تعداد کل داده‌ها سه، تعداد گام‌های زمانی گذشته مورد استفاده برای پیش‌بینی مدل برابر دو،
تعداد گره‌های گراف برابر دو و سایز کانال ورودی برابر یک است، در نتیجه ابعاد $Y$ به صورت $ 3 \times 2 \times 2 \times 1 $ در میاید.

همانطور که پیش‌تر اشاره شد در این پیچش لایه‌گذاری وجود ندارد در نتیجه ابعاد خروجی این لایه مانند ابعاد ورودی است به جز بعد دوم
که پس اعمال پیچش به اندازه‌ی $K_{t}-1$ کاهش میابد. حال اگر عرض $K_{t}$ را در مثالمان برابر ۲ در نظر بگیریم
بعد دوم ورودی به اندازه‌ی ۱ واحد کوچکتر و برابر با ۱ می‌گردد.

از آنجایی که مقادیر کرنل $\Gamma$ تصادفی می‌باشند، ادامه مثال ارزش افزوده‌ای نداشته بنابراین به آوردن مثال تا به این نقطه بسنده می‌کنیم.

در نهایت بلوک‌های پیچش زمانی-مکانی از رابطه \رجوع{eq:blocks} پیروی می‌کنند که در آن $L_{0}$ و $L_{1}$ به ترتیب کرنل‌ لایه‌های پیچشی زمانی پایینی و بالایی و $\Theta$ کرنل پیچش طیفی روی گراف می‌باشد.

\begin{equation}
v^{{l+1}} = \Gamma^{l}_{1} *_{\tau} ReLU( \Theta^{l} *_{g} (\Gamma_{0}^{l} *_{\tau} v^{l}) )
  \label{eq:blocks}
\end{equation}

بعد از روی هم قرار دادن دو بلوک پیچش زمانی-مکانی یک لایه‌ی کاملا متصل به عنوان لایه‌ی خروجی در انتها قرار می‌دهیم (مطابق شکل \رجوع{fig:blocks}).

\قسمت{پیش‌بینی برای چندگام زمانی آینده}
در این پروژه قصد داریم سرعت ترافیک در \متن‌لاتین{H} قدم زمانی بعدی را پیش‌بینی کنیم در مسایلی از این قبیل از چهار روش متفاوت می‌توانیم عمل کنیم:

\شروع{شمارش}

\فقره از آن جایی که در پروژه از شبکه‌های عصبی استفاده می‌کنیم و این مدل‌ها می‌توانند چندین خروجی داشته باشند، می‌توانیم در لایه‌ی آخر مدل شبکه‌ی عصبی خود به تعداد \متن‌لاتین{H} نورون قرار دهیم و با یک مدل سرعت ترافیک در \متن‌لاتین{H} قدم زمانی بعدی را پیش‌بینی کنیم.

\فقره می توانیم از روش مستقیم \پانویس{direct} استفاده کرده و برای هر خروجی یک مدل مجزا آموزش دهیم.

\فقره می توانیم از روش بازگشتی \پانویس{recursive} استفاده کنیم به طوری که خروجی مدل به عنوان ورودی به خود مدل داده می‌شود.

\فقره می توانیم از روش مستقیم-بازگشتی \پانویس{direct-recursive} استفاده کنیم در این روش مدل مجزایی برای هر خروجی آموزش داده می‌شود و همچنین خروجی یک مدل به عنوان ورودی به مدل بعدی داده می‌شود

\پایان{شمارش}

در این پروژه \متن‌لاتین{‌H} یک ابرپارامتر است و قصد نداریم آن را ثابت فرض کنیم به هین دلیل روش اول و همچنین روش مستقیم برای ما مناسب نیست و از روش بازگشتی استفاده می‌کنیم. لایه‌ی خروجی تنها یک کانال دارد و در نتیجه سرعت ترافیک را تنها برای یک گام بعدی می توان پیش‌بینی کرد در صورتی که در تعریف مساله بیان کرده بودیم قصد داریم این ویژگی را برای، $H$ قدم بعدی پیش‌بینی کنیم بدین منظور از روش پنجره‌ی لغزان\پانویس{window-based} استفاده می‌کنیم به این صورت که با استفاده از پنجره‌ای به طول $M$ از $M$ داده‌ی قبلی استفاده می‌کنیم تا سرعت ترافیک در گام بعدی را پیش‌بینی کنیم سپس این پنجره را یک واحد حرکت می دهیم به طوری که پیش‌بینی مدل در مرحله‌ی قبل حال به عنوان آخرین داده در این پنجره قرار می‌گیرد و برای پیش‌بینی سرعت در گام بعدی مورد استفاده قرار می‌گیرد، این روند را تا $H$ مرحله ادامه می دهیم. بدیهی است پیشی‌بینی مدل برای گام‌های ابتدایی دقیق‌تر از گام‌های انتهایی است.


\begin{figure}
  \includegraphics[width=\textwidth]{./images/recursive.png}
  \centering
  \caption{
روش بازگشتی در پیش‌بینی چند گام آینده }
  \label{fig:blocks}
\end{figure}


\قسمت{ابزارها و امکانات مورد نیاز}
مرتبه زمانی روش پیچش روی گراف به این دلیل که امکان استفاده از تبدیل سریع فوریه\پانویس{fast fourier transform} وجود ندارد،
\[
  O(n^{2})
\]
می‌باشد و اعمال این روش بدون داشتن تجهیزات گران قیمتی مانند پردازنده‌های گرافیکی زمان قابل توجهی است. حداقل امکانات مورد نیاز برای اجرای این پروژه عبارت اند از:

\begin{latin}\begin{itemize}
\item CPU: Intel(R) Xeon(R) CPU E5-2620 v4 @ 2.10GHz
\item GPU: NVIDIA GeForce GTX 1080
\end{itemize}\end{latin}

\قسمت{توضیح دیتاست}
مدل را دوبار به وسیله ی دو داده‌گان متفاوت آموزش دادیم.

\زیرقسمت{داده‌گان \متن‌لاتین{PeMSD7}}
این دیتاست توسط دوربین‌های سرعت‌سنجی که در نقاط مختلف قرار می‌گیرند جمع آوری شده‌اند. محل استقرار این دوربین‌ها ثابت است و کار ما در ساختن ماتریس فاصله بسیار ساده می کند همچنین سرعتی که این دوربین‌ها گزارش می‌دهند بسیار قابل اعتماد است و دیتاستی که با آن کار کردیم نیز داده‌ی پرت و یا گمشده‌ی کمی داشت و همانظور که در جدول \رجوع{} مشاهده می‌کنید مدل آموزش داده شده با این دیتاست دقت بالایی دارد.

\زیرقسمت{داده‌گان \متن‌لاتین{Snapp}}

این دیتاست توسط سیستم موقعیت‌‌یاب‌جهانی رانندگان جمع‌آوری شده‌است در نتیجه نمی‌توان سرعت ترافیک یک نقطه را پیدا کرد بلکه می‌توان
به طور مثال سرعت ترافیک در یک خیابان را دانست این موضوع ساختن ماتریس فاصله را مشکل می‌کند همچنین داده‌های آن به دلایل متعدی مانند
وجود ساختمان‌های بلند قابل اعتماد نیست. همچنین این داده در ابتدا سرعت ترافیک در یک خیابان نیستند بلکه سیگنال‌های \متن‌لاتین{GPS} رانندگان است. برای آماده کردن داده مراحل زیر انجام شده است.

\شروع{شمارش}

\فقره نوشتن \متن‌لاتین{cron job} برای گرفتن داده‌گان: به علت حجم بالای داده‌گان گرفتن تمام داده‌گان به صورت پشت‌سر‌هم مقدور نبود
در نتیجه \متن‌لاتین{cron job} نوشته شد تا در هر دقیقه تلاش کند و یک \متن‌لاتین{bulk} از دادگان را بگیرد.

\فقره نگاشت نقطه بر نقشه\پانویس{map matching}: سیگنال \متن‌لاتین{GPS} رانندگان به صورت دقیق بر روی خیابان نمی‌افتد و ابتدا باید خیابان مربوط به هر سیگنال \متن‌لاتین{‌GPS} را پیدا کنیم.

\شروع{شکل}
  \درج‌تصویر[height=8cm]{./images/mapMatch.png}
  \تنظیم‌ازوسط
  \شرح{نگاشت نقطه بر نقشه}
  \برچسب{fig:time-conv}
\پایان{شکل}

هر سیگنال \متن‌لاتین{GPS} متعلق به یک خیابان است که خیابان مورد نظر برای ما پنهان است و ما تنها سیگنال را می‌توانیم مشاهده کنیم
از طرفی ما رشته‌ی این سیگنال‌های \متن‌لاتین{GPS} را داریم، در نتیجه می‌توانیم از الگوریتم مدل پنهان مارکوف\پانویس{hidden markov model} \مرجع{Rabiner1986} استفاده کنیم.
برای هر سیگنال می توان $k$ خیابان نزدیک به آن را به عنوان حالت‌های پنهان احتمالی فرض کرد و سپس احتمالات انتشار و انتقال را به‌دست‌آورد.

\شروع{شکل}
  \درج‌تصویر[height=8cm]{./images/hmm.png}
  \تنظیم‌ازوسط
  \شرح{مدل پنهان مارکوف}
  \برچسب{fig:time-conv}
\پایان{شکل}

حال با استفاده از الگوریتم ویتربی\پانویس{viterbi} می توانیم محتمل‌ترین رشته و در نتیجه محتمل‌ترین نگاشت را پیدا کنیم.
پس از اتمام عملیات نگاشت می‌توانیم سرعت حرکت راننده، جهت حرکت او و شماره‌ی مرجع خیابان \پانویس{Road Segment ID} را پیدا کنیم.

\فقره محاسبه‌ی سرعت بر اساس سیگنال‌های \متن‌لاتین{GPS}: یکی از اطلاعاتی که سیگنال \متن‌لاتین{GPS} در اختیار ما قرار می‌دهد سرعت است اما این سرعت به صورت لحظه‌ای است و دارای خطای بسیار زیادی است به همین دلیل خود به محاسبه‌ی سرعت می‌پردازیم. پس از مرحله‌ی قبل که رشته‌ی \متن‌لاتین{GPS}های پشت‌سر‌هم به دست آمدند از تقسیم فاصله‌ی کروی دو سیگنال پشت‌سر‌هم بر اختلاف زمانی رخ دادن آن‌ها سرعت محاسبه می‌شود.


\فقره تمیز کردن دادگان: دادگان \متن‌لاتین{GPS} رانندگان دارای صفر و داده‌های پرت بسیاری است و نیاز دارد تا به دقت پیش‌پردازش شود. به طور مثال باید چک شود که دادگان راننده‌ّهایی که در حال سفر نیستند حذف شود.

\فقره حذف داده‌ی غیرقابل اعتماد: هدف در این پروژه ارایه‌ی مدلی بود که بتواند به خوبی سرعت ترافیک را پیش‌بینی کند مساله‌ی مسیریابی در حوزه‌ی کاری این پروژه نمی‌گنجد اما ذکر این موضوع خالی از لطف نیست که حتی اگر مدل ما توانایی بالایی در یادگیری دیتایی که به آن می‌ٔدهیم و پیش‌بینی سرعت ترافیک داشته باشد خطا در گام‌های اولیه مانند محاسبه‌ی سرعت باعث می‌شود دیتاستی که مدل قرار است به وسیله‌ی آن آموزش ببیند دارای نویز زیادی باشد و هدف ایده‌آل ما که مسیریابی است کاملا تحت‌الشعاع قرار می‌گیرد به همین دلیل در مکان‌هایی که دیتای قابل اعتمادی نداریم به طور مثال وقتی تعداد کل سیگنال‌های متن‌لاتین{GPS} که در یک خیابان مشخص در اختیار داریم از آستانه‌ی مشخصی پایین‌تر باشد سرعت آن خیابان را برابر general flow قرار می‌دهیم

\فقره رانندگان از بسیاری از خیابان‌ها مانند کوچه‌های محلی \پانویس{residential} عبور نمی‌کنند در نتیجه نمی‌توان سرعتی برای آن خیابان‌ها حساب کرد. در این پروژه ما ما \متن‌لاتین{SharedStreet}‌هایی را مورد مطالعه قرار دادیم که این اتفاق برایشان نمی‌افتد

\فقره برای نگاشت \متن‌لاتین{GPS}ها بر نقشه از پروژه‌ی متن باز \متن‌لاتین{https://github.com/bmwcarit/barefoot} که توسط شرکت \متن‌لاتین{BMW} توسعه داده شده است استفاده کرده‌ایم.

\پایان{شمارش}

در بالا صحبت شد که \متن‌لاتین{GPS}هاا باید بر نقشه نگاشت شوند درباره‌ی چگونگی تولید این نقشه در ادامه بیشتر صحبت می‌کنیم:

\زیرقسمت{سیستم مرجع sharedstreet}
استانداردهای داده‌ی \متن‌لاتین{SharedStreet} روشی است که بتوان به صورت منحصر به فرد خیابان‌ها را شناسایی کرد و داده‌گان مرتبط با آن خیابان را به آن متصل کرد. \متن‌لاتین{SharedStreet} این امکان را فراهم می‌آورد که نقشه‌های مختلف بتوانند با هم تعامل کنند و اجازه‌ی انتقال اطلاعات بین ارائه‌های مختلف خیابان‌ها را می‌دهد مانند داده‌گان مربوط به \متن‌لاتین{OpenStreetMap}، یک سیستم اطلاعات جغرافیایی\پانویس{Geographic Information System (GIS)} مدیریت شهری، نقشه‌های پایه‌ی تجاری\پانویس{commercial basemap}.

امروزه شهرها برای جمع‌آوری و اشتراک داده‌ها وابسته به سیستم اطلاعات جغرافیایی هستند اما این امر نیازمند این است که کاربران بر روی یک نقشه و یا استفاده از شناسه‌های از پیش تعریف شده و اغلب اختصاصی برای تعیین خیابان‌ها توافق کنند.

این امر پتانسیل همکاری و به اشتراک گذاری داده ها را بین سازمان های دولتی و بخش خصوصی را محدود می کند. و استفاده از نقشه های اختصاصی و سیستم های شناسایی می تواند توانایی شهرها را برای استفاده و به اشتراک گذاری اطلاعات عمومی مهم در مورد خیابان ها تضعیف کند.

\متن‌لاتین{SharedStreet} یک سیستم جهانی و غیر اختصاصی برای توصیف خیابان‌ها فراهم می‌کند که برای ترکیب هر منبع داده‌ای مرتبط با خیابان طراحی شده است. این به نهادهای دولتی و خصوصی اجازه می دهد تا با وضوح و دقت در مورد خیابان ها ارتباط برقرار کنند و در عین حال از سازگاری کامل با داده های نقشه داخلی سازمان ها اطمینان حاصل کنند.


\شروع{شکل}
  \درج‌تصویر[height=8cm]{./images/gis_vs_sharedstreets.png}
  \تنظیم‌ازوسط
  \شرح{سیستم \متن‌لاتین{sharedstreet} در برابر سیستم اطلاعات جغرافیایی}
  \برچسب{fig:time-conv}
 \پایان{شکل}

 \زیرقسمت{مفاهیم اصلی}

 سیستم مرجع \متن‌لاتین{sharedStreet} بر روی چهار لایه از داده ساخته شده است

\شروع{شمارش}

\فقره ارجاعات \متن‌لاتین{SharedStreet}: ارجاعات مستقل از نقشه‌ی پایه برای بخش‌هایی از خیابان که میان دو تقاطع قرار دارند.


\شروع{شکل}
  \درج‌تصویر[height=8cm]{./images/sharedstreets_references.png}
  \تنظیم‌ازوسط
  \شرح{ ارجاعات \متن‌لاتین{SharedStreet}}
  \برچسب{fig:time-conv}
\پایان{شکل}


\فقره تقاطع \متن‌لاتین{SharedStreet}: گره هایی که ارجاعات بخش های خیابان را به هم متصل می کنند.


\شروع{شکل}
  \درج‌تصویر[height=8cm]{./images/sharedstreets_intersections.png}
  \تنظیم‌ازوسط
  \شرح{ تقاطع \متن‌لاتین{SharedStreet}}
  \برچسب{fig:time-conv}
\پایان{شکل}


\فقره هندسه‌های \متن‌لاتین{SharedStreet}: هندسه های مورد استفاده برای تولید ارجاعات بخش خیابان
\شروع{شکل}
  \درج‌تصویر[height=8cm]{./images/sharedstreets_geometries.png}
  \تنظیم‌ازوسط
  \شرح{هندسه‌های \متن‌لاتین{SharedStreet}}
  \برچسب{fig:time-conv}
\پایان{شکل}


\فقره فراداده \متن‌لاتین{OSM}: راه‌های \متن‌لاتین{OSM} و ارجاعات گره مورد استفاده برای ساخت داده های \متن‌لاتین{SharedStreet}

\پایان{شمارش}

تیکه کدش از گیت هاب برنداشتم

به مجموعه‌ی \متن‌لاتین{SharedStreet}ها که شامل چهار نوع فایل توضیح داده شده در بالا است \متن‌لاتین{tile} گفته می‌شود. برای نگاشت نقطه بر نقشه به این \متن‌لاتین{tile} احتیاج داریم.برای ساختن این \متن‌لاتین{tile} مدت زمان زیادی نیاز دارد به طور مثال ساختن \متن‌لاتین{tile} شهر تهران که منطقه‌ی مورد مطالعه‌ی ما است حدود دو ساعت زمان برد.

\زیرقسمت{تجمیع سرعت رانندگان}

پس از نگاشت \متن‌لاتین{GPS} ها بر نقشه و محاسبه‌ی سرعت برای هر راننده، باید سرعت راننده‌هایی که در یک بازه‌ی زمانی نزدیک از یک خیابان رد شده اند را باهم تجمیع کنیم. در این پروژه ما بازه‌ی زمانی را برابر ۱۵ دقیقه در نظر گرفتیم. از قسمت قبل می‌توانیم چنین فایلی را تولید کنیم:

خط اول مربوط به راننده‌ی اول است

راننده‌ی اول: \متن‌لاتین{SharedStreet} اول، سرعت محاسبه شده توسط این راننده در \متن‌لاتین{SharedStreet} اول، تعداد سرعت محاسبه شده توسط این راننده در \متن‌لاتین{SharedStreet} اول;  \متن‌لاتین{SharedStreet} دوم، سرعت محاسبه شده توسط این راننده در \متن‌لاتین{SharedStreet} دوم، تعداد سرعت محاسبه شده توسط این راننده در \متن‌لاتین{SharedStreet} دوم;......


خط دوم مربوط به راننده‌ی دوم است:

راننده‌ی دوم: \متن‌لاتین{SharedStreet} اول سرعت محاسبه شده توسط این راننده در \متن‌لاتین{SharedStreet} اول تعداد سرعت محاسبه شده توسط این راننده در \متن‌لاتین{SharedStreet} اول;  \متن‌لاتین{SharedStreet} دوم، سرعت محاسبه شده توسط این راننده در \متن‌لاتین{SharedStreet} دوم، تعداد سرعت محاسبه شده توسط این راننده در \متن‌لاتین{SharedStreet} دوم;......

فرض کنید یک راننده در حال عبور از یک خیابان است و سه \متن‌لاتین{‌GPS} در آن خیابان می‌اندازد از \متن‌لاتین{GPS} اول و دوم یک سرعت و از \متن‌لاتین{‌GPS} دوم و سوم سرعتی دیگر محاسبه می‌شود. حال اگر \متن‌لاتین{GPS} اول و دوم یک دهم خیابان و \متن‌لاتین{GPS} دوم و سوم چهار دهم خیابان را در بر بگیرند. برای محاسبه‌ی سرعت کلی راننده در خیابان سرعت دوم، چهار برابر سرعت اول موثر است.

\شروع{شکل}
  \درج‌تصویر[height=8cm]{./images/speed_per_driver.drawio.png}
  \تنظیم‌ازوسط
  \شرح{ هندسه‌های \متن‌لاتین{SharedStreet}}
  \برچسب{fig:time-conv}
\پایان{شکل}

حجم داده‌ها بسیار زیاد است، برای سرعت در تجمیع از \متن‌لاتین{pyspark} استفاده کردیم. هنگام تجمیع سرعت‌ها ابتدا سرعت‌های پرت را حذف می‌کنیم همچنین سرعت راننده‌هایی که تعداد سرعت بیشتری برای آن‌ها در خیابان حساب کردیم وزن بیشتری در محاسبه‌ی سرعت کلی خیابان دارند. در نهایت برای هر خیابان به ازای هر ۱۵ دقیقه یک سرعت به دست می‌آوریم.

\زیرقسمت{ورودی مدل}

همانطور که بیان شد ما برای هر خیابان در هر بازه‌ی زمانی ۱۵ دقیقه به یک سرعت می‌رسیم اما در الگوریتم بیان شده ما نیاز به یک گراف داریم که سرعت ترافیک را در گره‌های این گراف پیش‌بینی می‌کنیم، همچنین ماتریس فاصله‌ی بین این گره‌ها را نیز نیاز داریم. در مجموعه داده‌ی \متن‌لاتین{PeMSD7} سرعت ترافیک توسط سنسورها اندازه‌گیری میشد که همان گره‌های گراف ما را تشکیل می‌دادند اما در این مجموعه داده با مشکل چگونگی ساخت گراف رو به رو هستیم. در این حالت وسط هر \متن‌لاتین{SharedStreet} را گره گراف در نظر گرفتیم حال به ماتریس فاصله‌ی میان گره‌ها نیاز داریم، چنین ماتریسی در دسترس نبود برای ساخت آن مختصات جغرافیایی گره‌های گراف را به دست آورده و سپس از رابط کاربری سرویس ماتریس فاصله‌ی شرکت نشان استفاده کردیم. شیوه‌ی فراخوانی این رابط کاربری بدین شکل است

\begin{latin}\begin{lstlisting}
GET:
    https://api.neshan.org/v1/distance-matrix
      ?origins=36.3177579,59.5323219|36.337115,59.530621
      &destinations=36.35067,59.5451965|36.337005,59.530021
Headers:
Api-Key: YOUR_API_KEY
\end{lstlisting}\end{latin}

با قرار دادن مختصات گره‌ها در هر دو قسمت مبدا و مقصد این سرویس ماتریس فاصله را به ما بر می‌گرداند. به مختصات جغرافیایی ابتدا و انتهای هر \متن‌لاتین{SharedStreet} دسترسی داریم، از آن جایی که طول \متن‌لاتین{SharedStreet} ها کوتاه است می توان سطح کروی کره‌ی زمین را در این \متن‌لاتین{SharedStreet} ها با صفحه تقریب زد در نتیجه برای به دست آوردن مختصات جغرافیایی وسط \متن‌لاتین{Sharedstreet} میانگین مختصات ابتدا و انتهای آن را حساب کردیم.

\زیرقسمت{خلاصه}
در این بخش راه حل پیشنهادی که به کار گرفتن یک شبکه‌ی پیچشی زمانی-مکانی بر روی گراف است مورد بحث قرار گرفت پیچیدگی زمانی بالای این مدل مورد انتقاد قرار گرفت و روش تخمین چبیشف برای حل آن توضیح داده شد. ساختار داخلی شبکه به تصویر کشیده شد.
